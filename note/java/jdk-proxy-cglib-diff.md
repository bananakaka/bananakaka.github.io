动态代理和cglib

CGLib(CODE GENERLIZE LIBRARY)所创建的动态代理对象的性能比JDK所创建的代理对象性能高不少，大概10倍，但CGLib在创建代理对象时所花费的时间却比JDK动态代理多大概8倍，所以对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建新的实例，所以比较适合CGLib动态代理技术，反之则适用于JDK动态代理技术。

由于CGLib采用动态创建子类并覆盖其中的方法的方式生成代理对象，所以不能对final类、类中的final，private方法进行处理。JDK动态代理只能对实现了接口的类生成代理，而不能针对类 。

CGLib底层使用ASM（JAVA字节码处理框架）在内存中动态的生成被代理类的子类。

jdk动态代理采用反射机制调用委托类的方法，所以运行速度会比CGLib慢。

当我们通过MyProxy的newProxyInstance()方法返回代理对象时，实际上是通过传入的接口和MyInvocationHandler生成了一个代理类的字节码，并而代理类中的真实对象的方法是通过反射机制进行调用的（我们在实现invoke方法时都是通过反射的APIMethod的invoke调用具体的方法可知），这也是JDK动态代理在创建代理对象快而运行时却比较慢的原因。



