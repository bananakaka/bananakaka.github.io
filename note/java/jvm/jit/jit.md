#### JIT是什么？为什么会出现JIT？JIT用来做什么？有哪些好处？

JIT 是 just in time 的缩写，意思是即时编译的编译器。javac将源码编译成字节码后，jvm对字节码逐条解释执行，这种方式执行速度相对较慢，尤其某个方法或代码块运行特别频繁时，这种方式的执行效率显得更低。因为解释执行的速度必然比编译成机器指令执行慢很多，为了提高执行速度，引入了JIT技术。这些频繁执行的代码被认定为Hot Spot Code(热点代码)，为了提高热点代码的效率，需要将这些代码编译成机器指令，并进行各层次的优化，完成这项任务的正是JIT编译器。

现在商用的vm如Sun的HotSpot、IBM的J9几乎都同时包含解释器和编译器，三大商用vm的JRockit是个例外，它没有解释器，因此启动时间会有点长，但它主要面向服务端的应用，一般不会关注启动时间。两者各有优势：编译执行可以提升效率，解释执行可以节约内存。

#### JIT是怎样编译的？

在运行时，JIT会把翻译过的机器指令缓存起来，以备下次使用。JIT默认是启用的，无需做额外配置。

下图是JIT的编译过程：

![](https://raw.githubusercontent.com/tinyivc/tinyivc.github.io/master/img/java/jvm/jit/jit-principle.jpg)

为什么当jvm执行代码时，并不立即编译代码？

1. 如果这些代码在将来只执行一次，那编译就是在浪费时间，有编译的功夫，jvm已经解释执行完了。如果一个方法或者一段代码频繁调用，例如循环，那编译就非常值得了。JIT就是将执行频率很高的字节码直接编译成机器指令，以method为翻译单位，保存起来。
2. 当jvm执行某一方法或循环的次数越多，就会更加了解代码结构，那么JIT在编译代码时会做出相应优化。

被即时编译的"热点代码"有两类：

- 多次被调用的方法
- 多次被调用的循环体

这两种情况，编译器都是以整个方法作为编译对象，这种方式也在jvm标准的编译方式。要知道一段代码是不是热点代码，需要进行Hot Spot Detection(热点探测)。目前主要热点探测有以下两种：

- **基于采样的热点探测**：采用这样的方法会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这段方法代码就是热点代码，这种方式是简单有效，还容易获取方法的调用关系，缺点是很难精确地确认一个方法的热度，因为容易受到阻塞线程或其他外界因素影响扰乱采样探测。
- **基于计数的热点探测**：这种方法会为每个方法甚至代码块建立计数器，统计方法执行次数，如果超过一定阈值，它就是"热点方法"，这种方法实现复杂一些，需要为每个代码块维护一个计数器，不能获取到调用关系，但它的统计结果相对精确。

在HotSpot jvm中，使用的是第二种—基于计数器的热点探测，它为每个方法准备了两个计数器：方法调用计数器、循环回边计数器。回边次数是循环完成的次数，continue那次不计入循环。

当确定运行参数的前提下，两个计数器都有一个确定的阈值，例如jvm每执行一次循环，循环计数器都会自增和自检，如果计数超出自身阈值，那么这个循环已具备编译资格，就会排队等待编译。当在JIT编译时，这是一个异步过程，允许在代码正在编译时继续执行。当编译完成后，下一次就会调用已编译的版本。

如果一个方法有很长的循环或者一个死循环提供了所有逻辑，这时jvm需要编译循环，不等方法被调用。这种编译叫做栈上替换(OSR)，因为即使循环被编译了，这也是不够的，jvm必须有能力在循环运行的时候，执行编译的版本。

JIT最重要的一个优化策略是可以决定何时从主存取值，何时从寄存器取值。例如循环累加的操作、方法动态绑定(equals)的操作。寄存器的使用是编译器非常普遍的优化。

方法内联也是JIT重要的优化策略之一。主要为了消除方法间调用，因为调用一个小方法可能比执行该小方法代码块耗时的多。JIT可以进行渐进内联，开始时内联简单的方法，如果可以进行其他优化，就接着优化内联后的代码块。用-XX:MaxInlineSize设置最大内联长度，用‑XX:FreqInlineSize设置频繁调用方法的阈值，注意：如果没有充分的分析，不应该修改这些配置。

#### 怎样通过JIT调优提高JVM运行效率？

##### 初级调优：client模式，server模式

这两种模式最大的差别在于：server启动速度较慢，一旦运行起来后，性能有很大提升。原因是client模式使用C1轻量级编译器，而server模式采用相对重量级C2编译器。C2编译的更为彻底，性能更高。

通过java -version查看当前jvm使用的是哪种模式。

##### 中级调优：代码缓存、编译阈值

###### 代码缓存

当JIT编译代码时，会将汇编指令集保存到代码缓存，缓存具有固定的大小，并且一旦被填满，就不能再编译更多的代码。

如果代码缓存很小，有些热点代码将不会被编译，应用将会运行大量解释代码。

在Java 7汇总，分层编译(server模式)默认的代码缓存通常是不够的，需要提高代码缓存大小。

目前并没有一个很好的机制确定代码缓存的大小，当需要提高代码缓存时，一般把设置成默认大小的2倍或4倍。

通过调整-XX:ReservedCodeCacheSize参数来优化，类似于jvm堆内存参数，有一个初始大小-XX:InitialCodeCacheSize，初始大小是基于芯片架构，例如Intel系列机器，client模式起始于160kb,server模式起始于2496kb，调整-XX:ReservedCodeCacheSize参数并不会真正影响性能，所以很有必要设置。

###### 编译阈值

阈值通过-XX:CompileThrehold设置，client模式下，N的值1500，server模式下，N的值是10000。把这个值调小店，虽然会提前编译代码，但是会降低jvm性能，因为可能会在非热点代码中花费更多的编译时间。有些优化只有在收集到足够多的统计信息才会进行，降低阈值反而不佳。经过测试，将阈值从8000变成10000，其实有很小影响。

##### 高级调优：编译线程

等待被编译的队列由多个编译线程执行，这些队列并不会严格遵守先进先出原则：哪个方法的计数器更高，哪个就有优先权。这个机制将帮助最重要的代码将被优先编译。

所以也就解释了为什么用jstat -printcompilation pid interval输出的结果中有时失序。

通过-XX:CICompilerCount调整，这是jvm执行队列所用的线程总数。



#### 关闭JIT

java.compiler=none

#### 如何分析JIT编译？

用JITWatch开源套件，它主要用来分析JIT编译的，其中Jarscan工具可以分析静态jar文件，检测应用中多少方法是对内联友好的，并给出超过频繁调用方法阈值的方法等信息、哪些方法不能进行JIT编译。

#### 开启-XX:+PrintCompilation



















