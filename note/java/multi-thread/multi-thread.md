

多线程有什么优势？

1. 发挥多核CPU的优势，充分利用每个CPU，真正地让多个线程并行执行。单核CPU不但不会发挥出多线程的优势，反而会导致线程上下文的切换，而降低程序整体的效率。为什么需要多线程呢？
2. 防止阻塞，单CPU单线程下，如果因为某个条件阻塞了，比如IO、读网络数据流等，多线程不会影响其他线程执行。

start()和run()的区别？

调用start()才会表现出多线程的特性，交替异步执行，调用run()是同步顺序执行。

Runnable接口和Callable接口的区别？

Runnable接口的run()的返回值是void，直接去执行代码，不关注执行结果。Callable接口的call()是有返回值的，返回结果是泛型，和Future、FutureTask配合可以用来获取异步执行的结果。例如在等待时间太长没获取到需要的数据的情况下取消该线程的任务。

CyclicBarrier和CountDownLatch的区别？

1. CyclicBarrier的某个线程运行到某个点之后，该线程停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点之后，只是给某个数值减1而已，该线程继续运行。
2. CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务。
3. CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了。

volatile作用？

保证变量内存可见性，防止指令重排序。读到的数据一定是最新的。因为防止指令重排序，一定程度上降低代码执行效率。CAS结合，保证了原子性，比如AtomicInteger。

一个线程如果出现了运行时异常会怎么样？

如果异常没有被捕获的话，这个线程就停止执行了。如果这个线程持有某个对象的监视器，那么这个对象监视器会被立即释放。

sleep()和wait()有什么区别？

都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep()不会放弃这个对象的监视器，wait()会放弃这个对象的监视器。

ThreadLocal有什么用？

是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，数据不共享。避免做资源互斥使用，线程同步等操作。

wait()和notify()/notifyAll()方法在放弃对象监视器时有什么区别？

wait()立即释放，notify()/notifyAll()会等待线程剩余临界区代码执行完毕才会放弃对象监视器。

synchronized和ReentrantLock的区别？

1. ReentrantLock可以对获取锁的等待时间进行设置
2. ReentrantLock可以获取各种锁的信息
3. ReentrantLock可以灵活地实现多路通知

二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word

ReadWriteLock是什么？

ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。

如何写一个会导致死锁的程序？

1. 线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50ms差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象锁。
2. 线程2的run()中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁。这样，线程1 sleep完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。

Java中用到的线程调度算法是什么？

抢占式。

Thread.sleep(0)的作用是什么？

由于Java采用抢占式的线程调度算法，因此可能会出现某个线程常常获取到CPU控制权的情况，为了让其他优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次OS分配时间片的操作，这也是平衡CPU控制权的一种操作。

Java内存模型？

Java内存模型将内存分为了主内存和工作内存。用到主存变量时，会读一次主存，拷贝一份数据到工作内存，线程运行时，读取自己的工作内存，执行完毕后，会把内容回写到主存。

happen-before

什么是CAS？

CAS，全称为Compare and Swap。假设有三个操作数：内存值V、预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值。

什么是AQS？

AQS全称AbstractQueuedSychronizer，翻译过来是抽象队列同步器。整个java并发包的核心，以双向队列连接所有的Entry，比方说ReentrantLock，所有等待的线程都放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列的第一个Entry开始运行。

Semaphore是什么？

Semaphore是一个信号量，作用是限制某段代码块的并发数。构造函数可以传入一个整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完这段代码块，下一个线程再进入。如果Semaphore构造函数传入的整数n=1，相当于变成了一个synchronized了。

Hashtable的size()中明明只有一条语句"return count"，为什么还要做同步？

同一个时间点只能有一个线程执行同步方法A，但对于某个非同步方法B，可以多个线程同时执行。这样就有个问题，方法A和方法B同时对一个变量进行操作。比如线程A在执行Hashtable的put()添加元素，线程B则可以正常调用size()读取当前Hashtable中元素的个数，那读取到的值可能不是最新的，可能线程A添加了完数据，但是没有对count++，线程B就已经读取count了。只有给size()变为同步方法，才能保证线程安全。

CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至编译后的代码只有一行，也不意味着对于底层来说一条语句的操作只有一个。一句"return count"假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。

同步方法和同步块，哪个更好？

通常情况下，同步块越小越好，以便同步块外的代码异步执行。但Java中还存在锁粗化的优化方法，这种方法就是把同步范围变大。比方说StringBuffer，它是一个线程安全的类，最常用的append()是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁、解锁，jvm在这个线程上要反复地在内核态和用户态之间进行切换，这对性能不利。因此jvm会将多次append()操作进行锁粗化的优化，从而减少解锁、加锁次数，提升效率。

































